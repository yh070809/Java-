which of the following best describes a multitasking operating system(多任务操作系统描述正确的是？)


A.An Operating System that can run multiple tasks concurrently on multiple CPUs
(多个CPU上同时运行多个任务)

B.An Operating System that can run single taksj concurrently across multiple CPU
(多个CPU 上运行同一个任务)

C.An Operating System that can run multiple taks concurrently on a Single CPU
(1个CPU上执行多个任务)

D.An operating system that constantly switches CPU time between loaded processes
(一个CPU上运行一个任务)



正确答案： C


先解释两个概念：   多用户和多任务

多用户： 允许同一时间内很多人使用同一部机器， 只要每个使用者都有自己的终端（terminal）

多任务： 为了使很多程序可以一起同时运行， 这个特点叫做多任务

多任务又分为协同式多任务和抢占式多任务

协同式多任务： 在一个多任务处理环境下，只有当其他程序认可时，一个运行程序才可以获得处理机时间。 每个程序必须协同的放弃对处理器的控制。 以便其他应用程序运行


抢占式多任务： 多任务处理的一种形式， 必要的时候，系统可以中断当前的任务，以便运行另外一个任务

那么CPU 的多任务抢占机制是如何实现的？
CPU 是通过设置时间中断来实现抢占机制的， 在进入保护模式之前， 先初始化中断向量表，在诗中中断入口放置任务切换代码，然后设置好时钟中断时间

当某一线程的执行用光了时间片的时候， 时钟中断产生，CPU 转去执行中断处的任务切换代码，保存当前线程的状态，得到并恢复下一个线程的状态，然后转去执行那个线程，以此类推



为了尽量的提高CPU 的利用率， 当某一个线程必须转入等待状态，如要获取某一低速外设的数据的时候，这里的读操作会主动放弃当前没有用光的时间片段，主动调用任务切换中断代码， 把CPU的时间让给其他已经准备好可以继续的线程

which permission, when applied to a directory in the file system , will allow a user to enter the directory ?


A. Read B Write C Excute D Access COntrol (访问控制权限)


IA 硬件架构， LInux 32 为操作系统下， 一个应用层的程序最多能分配和访问的内存大小是哪一个？

A 1GB B.2GB C 3GB 4 4GB
E 8GB F 硬件支持多少就能访问多少


所有的32位应用程序都有4GB 的进程地址空间 因为32位地址最多可以映射4GB 的内存  

对于windows 应用程序可以访问2GB的进程地址空间（32位Linux 可以访问3GB地址空间）

这就是被称为用户模式的虚拟地址空间 这2gb 的用户模式与你地址空间位于4GB地址空间的低一半 
而与之相对应的高一半2GB地址空间由操作系统内核使用， 因此被称为内核模式的虚拟地址空间。 在一个进程中， 所有的进程读共享相同的2GB用户模式的虚拟地址空间


为了缓解地址空间的不足， 微软提供了一个权益的解决方案， 所有从windows 2000 server开始的操作系统版本都提供了一个boot.ini的启动开关（一般大小为3GB）可以为应用程序提供访问3GB的进程地址空间的能力





假设就绪队列中有10个进程，系统将时间片设为200ms， CPU进程切换要花费10ms，则系统开销所占比例是多少？ 

A.1%  B.5% C. 10% D.20%

解析： 注意10个进程是在就绪队列里的，10个进程等效于2个进程。 
A_B_A_B...系统中A和B 不停的切换执行， 取一个周期， 从A到B再到A

2*10ms / 2*200ms = 5%


sleep() 和wait() 的区别


sleep（）是使线程停止一段时间的方法， 在sleep 的时间间隔期满以后， 线程不一定立即恢复执行

这是因为在这个时候，其他线程可能正在运行 而且没有被调度为放弃执行 ， 除非醒来的线程具有更高的优先级或者正在执行的线程因为其他原因而被阻塞


wait（） 

当线程交互的时候， 如果线程对同一个同步对象x 发出一个wait()调用 该线程会暂停执行
被调对象进入等待状态， 直到被唤醒或者等待时间到




win32 环境中有三种基本模式  分别是什么 他们的关系和各自的优缺点是什么

在Win32 环境中 线程有三种模式 单线程 单元线程和自由线程

为了对线程模式有一定的了解 我们可以将其想想成从一间屋子里搬运物品到另一间屋子里

如果采用单线程的方法 则需要自己完成从打包到扛箱子 再到拆包的所有工作  

如果使用单元线程模式 ， 则表示邀请了好朋友来帮忙，每个朋友在一个单独的房间里工作

而且并不能帮助在其他房间工作的人，他们各自负责自己的空间和空间内的物品搬运

如果采用自由线程的方法 仍然邀请相同的朋友来帮忙 但是所有的朋友都可以在任意一个房间里工作

共同打包物品
于此类似 房子就是所有线程的进程  每个朋友都是一个代码实例， 搬运的物品为应用程序的资源和变量


不同线程模式有自己的优点和缺点  单元线程比单线程要快 因为有多个组件实例在工作

在某些情况下 自有线程比单元线程要快 更有效因为所有的事情同时发生并且可以共享所有的资源 但是当多线程更改共享资源的时候

这可能会出现问题

假设一个人开始使用箱子打包厨房用具此时另外一个朋友进来了 要使用同一个箱子打包浴室的东西


第一个朋友在箱子上贴了“厨房用具” 标签 另一个朋友用“洗漱用品” 覆盖了原来的标签 结果当你拆包的时候

就会发生厨房用品搬到浴室的情况 


简单的应用程序很可能是单线程应用程序  仅包含于应用程序对应的线程

进程可以被定义为应用程序的实例  拥有该应用程序的内存空间  大多数windows 应用程序都是单线程的

即用一个线程完成所有的工作


单元线程是一种稍微复杂的线程模式 标记用于单元线程的代码可以在其自己的线程中执行并限制在自己的单元中




面试简答题： 同步和异步有何不同？ 在什么情况下分别使用它们？ 举例说明


如果数据将在线程间共享  例如： 正在写得数据以后可能被另外一个线程读到， 或者正在读的数据可能已经被另外一个线程写过了  那么这些数据就是共享数据

必须进行同步存取  当应用程序在对象上调用了一个需要花费很长时间来执行的方法 并且不希望让程序等待方法的返回时。就应该用异步编程 。 在很多情况下采用异步途径往往更有效率

面试简答题： 启动一个线程是run() 还是start() 

启动一个线程是调用start() 方法 使线程所代表的虚拟处理机处于可以运行的状态
这意味着他可以由JVM 调度并执行  但是并不意味着线程就会立即运行  run() 方法可以产生必须退出的标志来停止一个线程





面试简答题：  简述线程的基本概念，线程的基本状态

线程指在程序程序执行的过程中，能够执行程序代码的一个执行单位   每个程序至少有一个线程   也就是程序本身
JAVA 中的线程 有4种状态：  分别是 运行   就绪  挂起 结束


面试简答 简述synchrnized 和java.util.concurrent.locks.Lock 的异同 

主要相同点是 LOck 能够完成synchronized 所实现的所有功能 主要不同点是LOck 有更精确的线程语义和更好的性能

sychronized 会西东释放锁， 而LOCK 一定要求程序员手工释放 而且必须在finally 从句中释放 


