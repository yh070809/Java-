什么是快速排序？
快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

算法原理
单单看以上解释还是有些模糊，可以通过实例来理解它，下面通过一组数据来进行排序过程的解析：

原数组：{3，7，2，9，1，4，6，8，10，5}

期望结果：{1，2，3，4，5，6，7，8，9，10}

Demo步骤解析：

1.一开始选定数组的最后一个元素5作为基准值，也就是最终排序结果应该是以5为界限划分为左右两边。

2.从左边开始，寻找比5大的值，然后与5进行调换(因为如果比5小的值本来就应该排在5前面，比5大的值调换之后就去到了5的后面)，一路过来找到了7，将7与5调换，结束此次遍历。

3.从右边开始，由于7已经是上一轮排好序的便不再动它，从10开始，一路向左遍历，寻找比5小的值，然后与5进行调换(因为如果比5大的值本来就应该排在5后面，比5小的值调换之后就去到了5的后前面)，一路过来找到了4，将4与5调换，结束此次遍历。

4.从左边开始，由于3和4都是前两轮已经排好序的便不再动它，从2开始，一路向右遍历，寻找比5大的值，然后与5进行调换（道理同步骤2），一路过来找到了9，将9与5调换，结束此次遍历。

5.从右边开始，由于排在9后面的那几个数字都是上几轮排好序的便不再动它，从1开始，一路向右遍历，寻找比5小的值，然后与5进行调换(道理同步骤3)，一下子就找到了1，将1与5调换，结束此次遍历。

6.这个时候，发现5的左右两边都是排好序了的，所以结束此轮排序，5的左右两边抽出来各自进行下一轮的排序，规则同上，直到无法再拆分下去，即完成了整体的快速排序。


--------------------- 
Demo步骤解析：

1.一开始选定数组的最后一个元素5作为基准值，也就是最终排序结果应该是以5为界限划分为左右两边。

2.从左边开始，寻找比5大的值，然后与5进行调换(因为如果比5小的值本来就应该排在5前面，比5大的值调换之后就去到了5的后面)，一路过来找到了7，将7与5调换，结束此次遍历。

3.从右边开始，由于7已经是上一轮排好序的便不再动它，从10开始，一路向左遍历，寻找比5小的值，然后与5进行调换(因为如果比5大的值本来就应该排在5后面，比5小的值调换之后就去到了5的后前面)，一路过来找到了4，将4与5调换，结束此次遍历。

4.从左边开始，由于3和4都是前两轮已经排好序的便不再动它，从2开始，一路向右遍历，寻找比5大的值，然后与5进行调换（道理同步骤2），一路过来找到了9，将9与5调换，结束此次遍历。

5.从右边开始，由于排在9后面的那几个数字都是上几轮排好序的便不再动它，从1开始，一路向右遍历，寻找比5小的值，然后与5进行调换(道理同步骤3)，一下子就找到了1，将1与5调换，结束此次遍历。

6.这个时候，发现5的左右两边都是排好序了的，所以结束此轮排序，5的左右两边抽出来各自进行下一轮的排序，规则同上，直到无法再拆分下去，即完成了整体的快速排序。





算法实现
既然思路理清了,代码就容易上手了：


/**
 * 快速排序
 * @author IT_ZJYANG
 */
public class QuickSort {
    
    /**
     * 将数组的某一段元素进行划分，小的在左边，大的在右边
     * @param a
     * @param start
     * @param end
     * @return
     */
    public static int divide(int[] a, int start, int end){
        //每次都以最右边的元素作为基准值
        int base = a[end];
        //start一旦等于end，就说明左右两个指针合并到了同一位置，可以结束此轮循环。
        while(start < end){
            while(start < end && a[start] <= base)
                //从左边开始遍历，如果比基准值小，就继续向右走
                start++;
            //上面的while循环结束时，就说明当前的a[start]的值比基准值大，应与基准值进行交换
            if(start < end){
                //交换
                int temp = a[start];
                a[start] = a[end];
                a[end] = temp;
                //交换后，此时的那个被调换的值也同时调到了正确的位置(基准值右边)，因此右边也要同时向前移动一位
                end--;
            }   
            while(start < end && a[end] >= base)
                //从右边开始遍历，如果比基准值大，就继续向左走
                end--;
            //上面的while循环结束时，就说明当前的a[end]的值比基准值小，应与基准值进行交换
            if(start < end){
                //交换
                int temp = a[start];
                a[start] = a[end];
                a[end] = temp;
                //交换后，此时的那个被调换的值也同时调到了正确的位置(基准值左边)，因此左边也要同时向后移动一位
                start++;
            }   
            
        }
        //这里返回start或者end皆可，此时的start和end都为基准值所在的位置
        return end;
    }
 
    /**
     * 排序
     * @param a
     * @param start
     * @param end
     */
    public static void sort(int[] a, int start, int end){
        if(start > end){
            //如果只有一个元素，就不用再排下去了
            return;
        } 
        else{
            //如果不止一个元素，继续划分两边递归排序下去
            int partition = divide(a, start, end);
            sort(a, start, partition-1);
            sort(a, partition+1, end);
        }
            
    }
    
}

