下面说法中哪项是正确的 ？（多选）

A.Java 虚拟机中的自动垃圾回收机组织程序运行溢出内存
B.一段程序可以建议垃圾回收执行，但是不能强迫他执行
C.垃圾回收是一个独立的平台
D.当一个对象的所有引用都被设置为空的时候，这个对象就能变成为垃圾回收


答案 B,D

解析： 如果一个程序保持创建一个引用对象时 其他的任何引用没有被抛弃，也会造成内存耗尽的结果。垃圾回收不是一个独立的平台，它具有平台依赖性
Java 垃圾回收机制:gc 即垃圾收集机制，是指JVM用于释放那些不再使用的对象所占的内存
Java语言并不要求JVM有gc，也没有规定gc如何工作，不过常用的JVM都有gc，而且大多数gc都使用类似的算法管理内存和执行收集操作。Java的垃圾回收机制是为所有的Java应用进程服务的，而不是为了某一个特定的进程服务的。因此，任何一个进程都不能命令垃圾回收机制做什么，怎么做或者做多少。在JVM垃圾收集器收集一个对象之前，一般要求程序调用适当的方法释放资源，但在没有明确释放资源的情况下，Java提供了默认机制终止化该对象来释放资源
这个方法就是finalize（）它的原型为protected void finalized () throws Throwable .在fianlize() 方法返回之后，对象消失，垃圾收集开始执行， 原型中的throws Throwable 表示他可以抛出任何类型的异常




下列代码中 第几行的sobj符合垃圾收集器的收费标准

1. Object sobj = new Object();
2. Object sobj = null;
3. Object sobj = new Object();
4. sobjc = new Object();

答案：1,3

因为第二行将sobj赋值为null，所以第一行的sobj 符合垃圾收集器的收集标准，而第四行相当于将sobj赋值为null，所以第三行的sobj也符合垃圾收集器的收集标准



如果有一个对象的句柄a, 且你把a作为某个构造器的参数，即new Constructor （a），则即使你将a赋值为null,a也不符合垃圾收集器的收集标准。直到由上面构造器构造的新对象被赋空值时，a才可以被垃圾收集器收集